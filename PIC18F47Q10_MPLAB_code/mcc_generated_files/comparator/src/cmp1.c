#include <xc.h>
#include "../cmp1.h"

static void (*CMP1_InterruptHandler)(void);
static void CMP1_DefaultInterruptCallback(void);


void CMP1_Initialize(void) 
{
    /* Disable CMP1 interrupt before configuring the CMP1
      control register. Although a comparator is disabled, an interrupt can be
      generated by changing the output polarity with the CxPOL bit of the
      CMxCON0 register,or by switching the comparator on or off with the CxON
      bit of the CMxCON0 register.*/
    PIE2bits.C1IE = 0;

    // CHYS enabled; CON enabled; CPOL not inverted; CSYNC asynchronous; 
    CM1CON0 = 0x82;

    // CINTN intFlag_neg; CINTP intFlag_pos; 
    CM1CON1 = 0x3;
    
    // CNCH CIN1-; 
    CM1NCH = 0x1;
    
    // CPCH CIN1+; 
    CM1PCH = 0x1;    

    //CMP1_InterruptCallbackRegister(CMP1_DefaultInterruptCallback);

    // Clearing IF flag before enabling the interrupt.
    PIR2bits.C1IF = 0;     

    // Enabling CMP1 interrupt.
    PIE2bits.C1IE = 1;
}

void CMP1_Enable(void) 
{
    CM1CON0bits.C1EN = 1;
}

void CMP1_Disable(void) 
{
    CM1CON0bits.C1EN = 0;
}

bool CMP1_GetOutputStatus(void) 
{
    return CM1CON0bits.C1OUT; /* Note : As per datasheet, CxOUT bit in CMOUT register (if relevant) 
                                                   is mirror copy of CMxCON0.OUT */
    //PPS nisam namjestio tako da output ne bi smjeo bit nigdje, ali ako nesto baca negjde vani moglo bi stvarat problem
}

//void CMP1_ISR(void) 
//{
//    // Clear the CMP1 interrupt flag
//    PIR2bits.C1IF = 0;
//
//    if(CMP1_InterruptHandler != NULL)
//    {
//      CMP1_InterruptHandler();
//    }
//}

void CMP1_InterruptCallbackRegister(void(*callbackHandler)(void))
{
    if(NULL != callbackHandler)
    {
      CMP1_InterruptHandler = callbackHandler;
    }
}

static void CMP1_DefaultInterruptCallback(void)
{
    //Add your interrupt code here or
    //Use CMP1_InterruptCallbackRegister function to use Custom ISR

}